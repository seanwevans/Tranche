// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const getActiveServices = `-- name: GetActiveServices :many
SELECT id, customer_id, name, primary_cdn, backup_cdn, created_at, deleted_at
FROM services
WHERE deleted_at IS NULL
ORDER BY id
`

func (q *Queries) GetActiveServices(ctx context.Context) ([]Service, error) {
	rows, err := q.db.QueryContext(ctx, getActiveServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Name,
			&i.PrimaryCdn,
			&i.BackupCdn,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveStormForPolicy = `-- name: GetActiveStormForPolicy :one
SELECT id, service_id, kind, started_at, ended_at
FROM storm_events
WHERE service_id = $1
  AND kind = $2
  AND ended_at IS NULL
ORDER BY started_at DESC
LIMIT 1
`

type GetActiveStormForPolicyParams struct {
	ServiceID int64  `json:"service_id"`
	Kind      string `json:"kind"`
}

func (q *Queries) GetActiveStormForPolicy(ctx context.Context, arg GetActiveStormForPolicyParams) (StormEvent, error) {
	row := q.db.QueryRowContext(ctx, getActiveStormForPolicy, arg.ServiceID, arg.Kind)
	var i StormEvent
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Kind,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const getActiveStormsForService = `-- name: GetActiveStormsForService :many
SELECT id, service_id, kind, started_at, ended_at
FROM storm_events
WHERE service_id = $1
  AND ended_at IS NULL
`

func (q *Queries) GetActiveStormsForService(ctx context.Context, serviceID int64) ([]StormEvent, error) {
	rows, err := q.db.QueryContext(ctx, getActiveStormsForService, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StormEvent{}
	for rows.Next() {
		var i StormEvent
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Kind,
			&i.StartedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastStormEvent = `-- name: GetLastStormEvent :one
SELECT id, service_id, kind, started_at, ended_at
FROM storm_events
WHERE service_id = $1
  AND kind = $2
ORDER BY started_at DESC
LIMIT 1
`

type GetLastStormEventParams struct {
	ServiceID int64  `json:"service_id"`
	Kind      string `json:"kind"`
}

func (q *Queries) GetLastStormEvent(ctx context.Context, arg GetLastStormEventParams) (StormEvent, error) {
	row := q.db.QueryRowContext(ctx, getLastStormEvent, arg.ServiceID, arg.Kind)
	var i StormEvent
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Kind,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const getServiceDomains = `-- name: GetServiceDomains :many
SELECT id, service_id, name, created_at
FROM service_domains
WHERE service_id = $1
ORDER BY id
`

func (q *Queries) GetServiceDomains(ctx context.Context, serviceID int64) ([]ServiceDomain, error) {
	rows, err := q.db.QueryContext(ctx, getServiceDomains, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ServiceDomain{}
	for rows.Next() {
		var i ServiceDomain
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Name,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStormPoliciesForService = `-- name: GetStormPoliciesForService :many
SELECT id, service_id, kind, threshold_avail, window_seconds, cooldown_seconds, max_coverage_factor, created_at
FROM storm_policies
WHERE service_id = $1
ORDER BY id
`

func (q *Queries) GetStormPoliciesForService(ctx context.Context, serviceID int64) ([]StormPolicy, error) {
	rows, err := q.db.QueryContext(ctx, getStormPoliciesForService, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StormPolicy{}
	for rows.Next() {
		var i StormPolicy
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Kind,
			&i.ThresholdAvail,
			&i.WindowSeconds,
			&i.CooldownSeconds,
			&i.MaxCoverageFactor,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertStormEvent = `-- name: InsertStormEvent :one
INSERT INTO storm_events (service_id, kind)
VALUES ($1, $2)
RETURNING id, service_id, kind, started_at, ended_at
`

type InsertStormEventParams struct {
	ServiceID int64  `json:"service_id"`
	Kind      string `json:"kind"`
}

func (q *Queries) InsertStormEvent(ctx context.Context, arg InsertStormEventParams) (StormEvent, error) {
	row := q.db.QueryRowContext(ctx, insertStormEvent, arg.ServiceID, arg.Kind)
	var i StormEvent
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Kind,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const markStormEventResolved = `-- name: MarkStormEventResolved :one
UPDATE storm_events
SET ended_at = $2
WHERE id = $1
RETURNING id, service_id, kind, started_at, ended_at
`

type MarkStormEventResolvedParams struct {
	ID      int64        `json:"id"`
	EndedAt sql.NullTime `json:"ended_at"`
}

func (q *Queries) MarkStormEventResolved(ctx context.Context, arg MarkStormEventResolvedParams) (StormEvent, error) {
	row := q.db.QueryRowContext(ctx, markStormEventResolved, arg.ID, arg.EndedAt)
	var i StormEvent
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Kind,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}
