// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const deleteServiceDomain = `-- name: DeleteServiceDomain :one
DELETE FROM service_domains
WHERE id = $1
  AND service_id = $2
RETURNING id, service_id, name, created_at
`

type DeleteServiceDomainParams struct {
	ID        int64 `json:"id"`
	ServiceID int64 `json:"service_id"`
}

func (q *Queries) DeleteServiceDomain(ctx context.Context, arg DeleteServiceDomainParams) (ServiceDomain, error) {
	row := q.db.QueryRowContext(ctx, deleteServiceDomain, arg.ID, arg.ServiceID)
	var i ServiceDomain
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const deleteStormPolicy = `-- name: DeleteStormPolicy :one
DELETE FROM storm_policies
WHERE id = $1
  AND service_id = $2
RETURNING id, service_id, kind, threshold_avail, window_seconds, cooldown_seconds, max_coverage_factor, created_at
`

type DeleteStormPolicyParams struct {
	ID        int64 `json:"id"`
	ServiceID int64 `json:"service_id"`
}

func (q *Queries) DeleteStormPolicy(ctx context.Context, arg DeleteStormPolicyParams) (StormPolicy, error) {
	row := q.db.QueryRowContext(ctx, deleteStormPolicy, arg.ID, arg.ServiceID)
	var i StormPolicy
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Kind,
		&i.ThresholdAvail,
		&i.WindowSeconds,
		&i.CooldownSeconds,
		&i.MaxCoverageFactor,
		&i.CreatedAt,
	)
	return i, err
}

const getActiveServices = `-- name: GetActiveServices :many
SELECT id, customer_id, name, primary_cdn, backup_cdn, created_at, deleted_at
FROM services
WHERE deleted_at IS NULL
ORDER BY id
`

func (q *Queries) GetActiveServices(ctx context.Context) ([]Service, error) {
	rows, err := q.db.QueryContext(ctx, getActiveServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Name,
			&i.PrimaryCdn,
			&i.BackupCdn,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveServicesForCustomer = `-- name: GetActiveServicesForCustomer :many
SELECT id, customer_id, name, primary_cdn, backup_cdn, created_at, deleted_at
FROM services
WHERE deleted_at IS NULL
  AND customer_id = $1
ORDER BY id
`

func (q *Queries) GetActiveServicesForCustomer(ctx context.Context, customerID int64) ([]Service, error) {
	rows, err := q.db.QueryContext(ctx, getActiveServicesForCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Name,
			&i.PrimaryCdn,
			&i.BackupCdn,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveStormForPolicy = `-- name: GetActiveStormForPolicy :one
SELECT id, service_id, kind, started_at, ended_at
FROM storm_events
WHERE service_id = $1
  AND kind = $2
  AND ended_at IS NULL
ORDER BY started_at DESC
LIMIT 1
`

type GetActiveStormForPolicyParams struct {
	ServiceID int64  `json:"service_id"`
	Kind      string `json:"kind"`
}

func (q *Queries) GetActiveStormForPolicy(ctx context.Context, arg GetActiveStormForPolicyParams) (StormEvent, error) {
	row := q.db.QueryRowContext(ctx, getActiveStormForPolicy, arg.ServiceID, arg.Kind)
	var i StormEvent
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Kind,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const getActiveStormsForService = `-- name: GetActiveStormsForService :many
SELECT id, service_id, kind, started_at, ended_at
FROM storm_events
WHERE service_id = $1
  AND ended_at IS NULL
`

func (q *Queries) GetActiveStormsForService(ctx context.Context, serviceID int64) ([]StormEvent, error) {
	rows, err := q.db.QueryContext(ctx, getActiveStormsForService, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StormEvent{}
	for rows.Next() {
		var i StormEvent
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Kind,
			&i.StartedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastStormEvent = `-- name: GetLastStormEvent :one
SELECT id, service_id, kind, started_at, ended_at
FROM storm_events
WHERE service_id = $1
  AND kind = $2
ORDER BY started_at DESC
LIMIT 1
`

type GetLastStormEventParams struct {
	ServiceID int64  `json:"service_id"`
	Kind      string `json:"kind"`
}

func (q *Queries) GetLastStormEvent(ctx context.Context, arg GetLastStormEventParams) (StormEvent, error) {
	row := q.db.QueryRowContext(ctx, getLastStormEvent, arg.ServiceID, arg.Kind)
	var i StormEvent
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Kind,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const getMaxCoverageFactorForService = `-- name: GetMaxCoverageFactorForService :one
SELECT COALESCE(MAX(max_coverage_factor), 1.0)::double precision AS max_coverage_factor
FROM storm_policies
WHERE service_id = $1
`

func (q *Queries) GetMaxCoverageFactorForService(ctx context.Context, serviceID int64) (float64, error) {
	row := q.db.QueryRowContext(ctx, getMaxCoverageFactorForService, serviceID)
	var max_coverage_factor float64
	err := row.Scan(&max_coverage_factor)
	return max_coverage_factor, err
}

const getServiceDomains = `-- name: GetServiceDomains :many
SELECT id, service_id, name, created_at
FROM service_domains
WHERE service_id = $1
ORDER BY id
`

func (q *Queries) GetServiceDomains(ctx context.Context, serviceID int64) ([]ServiceDomain, error) {
	rows, err := q.db.QueryContext(ctx, getServiceDomains, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ServiceDomain{}
	for rows.Next() {
		var i ServiceDomain
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Name,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceForCustomer = `-- name: GetServiceForCustomer :one
SELECT id, customer_id, name, primary_cdn, backup_cdn, created_at, deleted_at
FROM services
WHERE id = $1
  AND customer_id = $2
  AND deleted_at IS NULL
`

type GetServiceForCustomerParams struct {
	ID         int64 `json:"id"`
	CustomerID int64 `json:"customer_id"`
}

func (q *Queries) GetServiceForCustomer(ctx context.Context, arg GetServiceForCustomerParams) (Service, error) {
	row := q.db.QueryRowContext(ctx, getServiceForCustomer, arg.ID, arg.CustomerID)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Name,
		&i.PrimaryCdn,
		&i.BackupCdn,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getStormEventsForWindow = `-- name: GetStormEventsForWindow :many
SELECT id, service_id, kind, started_at, ended_at
FROM storm_events
WHERE service_id = $1
  AND started_at < $2
  AND (ended_at IS NULL OR ended_at > $3)
ORDER BY started_at
`

type GetStormEventsForWindowParams struct {
	ServiceID   int64        `json:"service_id"`
	WindowEnd   time.Time    `json:"window_end"`
	WindowStart sql.NullTime `json:"window_start"`
}

func (q *Queries) GetStormEventsForWindow(ctx context.Context, arg GetStormEventsForWindowParams) ([]StormEvent, error) {
	rows, err := q.db.QueryContext(ctx, getStormEventsForWindow, arg.ServiceID, arg.WindowEnd, arg.WindowStart)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StormEvent{}
	for rows.Next() {
		var i StormEvent
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Kind,
			&i.StartedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStormPoliciesForService = `-- name: GetStormPoliciesForService :many
SELECT id, service_id, kind, threshold_avail, window_seconds, cooldown_seconds, max_coverage_factor, created_at
FROM storm_policies
WHERE service_id = $1
ORDER BY id
`

func (q *Queries) GetStormPoliciesForService(ctx context.Context, serviceID int64) ([]StormPolicy, error) {
	rows, err := q.db.QueryContext(ctx, getStormPoliciesForService, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StormPolicy{}
	for rows.Next() {
		var i StormPolicy
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.Kind,
			&i.ThresholdAvail,
			&i.WindowSeconds,
			&i.CooldownSeconds,
			&i.MaxCoverageFactor,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStormPolicyForService = `-- name: GetStormPolicyForService :one
SELECT id, service_id, kind, threshold_avail, window_seconds, cooldown_seconds, max_coverage_factor, created_at
FROM storm_policies
WHERE id = $1
  AND service_id = $2
`

type GetStormPolicyForServiceParams struct {
	ID        int64 `json:"id"`
	ServiceID int64 `json:"service_id"`
}

func (q *Queries) GetStormPolicyForService(ctx context.Context, arg GetStormPolicyForServiceParams) (StormPolicy, error) {
	row := q.db.QueryRowContext(ctx, getStormPolicyForService, arg.ID, arg.ServiceID)
	var i StormPolicy
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Kind,
		&i.ThresholdAvail,
		&i.WindowSeconds,
		&i.CooldownSeconds,
		&i.MaxCoverageFactor,
		&i.CreatedAt,
	)
	return i, err
}

const getUnbilledUsageSnapshots = `-- name: GetUnbilledUsageSnapshots :many
SELECT
    us.id,
    us.service_id,
    s.customer_id,
    us.window_start,
    us.window_end,
    us.primary_bytes,
    us.backup_bytes
FROM usage_snapshots us
JOIN services s ON s.id = us.service_id
WHERE us.invoice_id IS NULL
  AND us.window_end <= $1
  AND us.window_end > $2
ORDER BY us.window_start
`

const lockUnbilledUsageSnapshots = `-- name: LockUnbilledUsageSnapshots :many
SELECT
    us.id,
    us.service_id,
    s.customer_id,
    us.window_start,
    us.window_end,
    us.primary_bytes,
    us.backup_bytes
FROM usage_snapshots us
JOIN services s ON s.id = us.service_id
WHERE us.invoice_id IS NULL
  AND us.window_end <= $1
  AND us.window_end > $2
ORDER BY us.window_start
FOR UPDATE SKIP LOCKED
`

type GetUnbilledUsageSnapshotsParams struct {
	WindowEnd   time.Time `json:"window_end"`
	WindowStart time.Time `json:"window_start"`
}

type GetUnbilledUsageSnapshotsRow struct {
	ID           int64     `json:"id"`
	ServiceID    int64     `json:"service_id"`
	CustomerID   int64     `json:"customer_id"`
	WindowStart  time.Time `json:"window_start"`
	WindowEnd    time.Time `json:"window_end"`
	PrimaryBytes int64     `json:"primary_bytes"`
	BackupBytes  int64     `json:"backup_bytes"`
}

func (q *Queries) GetUnbilledUsageSnapshots(ctx context.Context, arg GetUnbilledUsageSnapshotsParams) ([]GetUnbilledUsageSnapshotsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnbilledUsageSnapshots, arg.WindowEnd, arg.WindowStart)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnbilledUsageSnapshotsRow{}
	for rows.Next() {
		var i GetUnbilledUsageSnapshotsRow
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.CustomerID,
			&i.WindowStart,
			&i.WindowEnd,
			&i.PrimaryBytes,
			&i.BackupBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type LockUnbilledUsageSnapshotsParams struct {
	WindowEnd   time.Time `json:"window_end"`
	WindowStart time.Time `json:"window_start"`
}

type LockUnbilledUsageSnapshotsRow struct {
	ID           int64     `json:"id"`
	ServiceID    int64     `json:"service_id"`
	CustomerID   int64     `json:"customer_id"`
	WindowStart  time.Time `json:"window_start"`
	WindowEnd    time.Time `json:"window_end"`
	PrimaryBytes int64     `json:"primary_bytes"`
	BackupBytes  int64     `json:"backup_bytes"`
}

func (q *Queries) LockUnbilledUsageSnapshots(ctx context.Context, arg LockUnbilledUsageSnapshotsParams) ([]LockUnbilledUsageSnapshotsRow, error) {
	rows, err := q.db.QueryContext(ctx, lockUnbilledUsageSnapshots, arg.WindowEnd, arg.WindowStart)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LockUnbilledUsageSnapshotsRow{}
	for rows.Next() {
		var i LockUnbilledUsageSnapshotsRow
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.CustomerID,
			&i.WindowStart,
			&i.WindowEnd,
			&i.PrimaryBytes,
			&i.BackupBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertInvoice = `-- name: InsertInvoice :one
INSERT INTO invoices (customer_id, period_start, period_end, subtotal_cents, discount_cents, total_cents)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, customer_id, period_start, period_end, subtotal_cents, discount_cents, total_cents, created_at
`

type InsertInvoiceParams struct {
	CustomerID    int64     `json:"customer_id"`
	PeriodStart   time.Time `json:"period_start"`
	PeriodEnd     time.Time `json:"period_end"`
	SubtotalCents int64     `json:"subtotal_cents"`
	DiscountCents int64     `json:"discount_cents"`
	TotalCents    int64     `json:"total_cents"`
}

func (q *Queries) InsertInvoice(ctx context.Context, arg InsertInvoiceParams) (Invoice, error) {
	row := q.db.QueryRowContext(ctx, insertInvoice,
		arg.CustomerID,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.SubtotalCents,
		arg.DiscountCents,
		arg.TotalCents,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.SubtotalCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.CreatedAt,
	)
	return i, err
}

const insertInvoiceLineItem = `-- name: InsertInvoiceLineItem :one
INSERT INTO invoice_line_items (
    invoice_id,
    service_id,
    window_start,
    window_end,
    primary_bytes,
    backup_bytes,
    coverage_factor,
    amount_cents,
    discount_cents
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, invoice_id, service_id, window_start, window_end, primary_bytes, backup_bytes, coverage_factor, amount_cents, discount_cents, created_at
`

type InsertInvoiceLineItemParams struct {
	InvoiceID      int64     `json:"invoice_id"`
	ServiceID      int64     `json:"service_id"`
	WindowStart    time.Time `json:"window_start"`
	WindowEnd      time.Time `json:"window_end"`
	PrimaryBytes   int64     `json:"primary_bytes"`
	BackupBytes    int64     `json:"backup_bytes"`
	CoverageFactor float64   `json:"coverage_factor"`
	AmountCents    int64     `json:"amount_cents"`
	DiscountCents  int64     `json:"discount_cents"`
}

func (q *Queries) InsertInvoiceLineItem(ctx context.Context, arg InsertInvoiceLineItemParams) (InvoiceLineItem, error) {
	row := q.db.QueryRowContext(ctx, insertInvoiceLineItem,
		arg.InvoiceID,
		arg.ServiceID,
		arg.WindowStart,
		arg.WindowEnd,
		arg.PrimaryBytes,
		arg.BackupBytes,
		arg.CoverageFactor,
		arg.AmountCents,
		arg.DiscountCents,
	)
	var i InvoiceLineItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.ServiceID,
		&i.WindowStart,
		&i.WindowEnd,
		&i.PrimaryBytes,
		&i.BackupBytes,
		&i.CoverageFactor,
		&i.AmountCents,
		&i.DiscountCents,
		&i.CreatedAt,
	)
	return i, err
}

const insertService = `-- name: InsertService :one
INSERT INTO services (customer_id, name, primary_cdn, backup_cdn)
VALUES ($1, $2, $3, $4)
RETURNING id, customer_id, name, primary_cdn, backup_cdn, created_at, deleted_at
`

type InsertServiceParams struct {
	CustomerID int64  `json:"customer_id"`
	Name       string `json:"name"`
	PrimaryCdn string `json:"primary_cdn"`
	BackupCdn  string `json:"backup_cdn"`
}

func (q *Queries) InsertService(ctx context.Context, arg InsertServiceParams) (Service, error) {
	row := q.db.QueryRowContext(ctx, insertService,
		arg.CustomerID,
		arg.Name,
		arg.PrimaryCdn,
		arg.BackupCdn,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Name,
		&i.PrimaryCdn,
		&i.BackupCdn,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const insertServiceDomain = `-- name: InsertServiceDomain :one
INSERT INTO service_domains (service_id, name)
VALUES ($1, $2)
RETURNING id, service_id, name, created_at
`

type InsertServiceDomainParams struct {
	ServiceID int64  `json:"service_id"`
	Name      string `json:"name"`
}

func (q *Queries) InsertServiceDomain(ctx context.Context, arg InsertServiceDomainParams) (ServiceDomain, error) {
	row := q.db.QueryRowContext(ctx, insertServiceDomain, arg.ServiceID, arg.Name)
	var i ServiceDomain
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const insertStormEvent = `-- name: InsertStormEvent :one
INSERT INTO storm_events (service_id, kind)
VALUES ($1, $2)
RETURNING id, service_id, kind, started_at, ended_at
`

type InsertStormEventParams struct {
	ServiceID int64  `json:"service_id"`
	Kind      string `json:"kind"`
}

func (q *Queries) InsertStormEvent(ctx context.Context, arg InsertStormEventParams) (StormEvent, error) {
	row := q.db.QueryRowContext(ctx, insertStormEvent, arg.ServiceID, arg.Kind)
	var i StormEvent
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Kind,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const insertStormPolicy = `-- name: InsertStormPolicy :one
INSERT INTO storm_policies (
        service_id,
        kind,
        threshold_avail,
        window_seconds,
        cooldown_seconds,
        max_coverage_factor)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, service_id, kind, threshold_avail, window_seconds, cooldown_seconds, max_coverage_factor, created_at
`

type InsertStormPolicyParams struct {
	ServiceID         int64   `json:"service_id"`
	Kind              string  `json:"kind"`
	ThresholdAvail    float64 `json:"threshold_avail"`
	WindowSeconds     int32   `json:"window_seconds"`
	CooldownSeconds   int32   `json:"cooldown_seconds"`
	MaxCoverageFactor float64 `json:"max_coverage_factor"`
}

func (q *Queries) InsertStormPolicy(ctx context.Context, arg InsertStormPolicyParams) (StormPolicy, error) {
	row := q.db.QueryRowContext(ctx, insertStormPolicy,
		arg.ServiceID,
		arg.Kind,
		arg.ThresholdAvail,
		arg.WindowSeconds,
		arg.CooldownSeconds,
		arg.MaxCoverageFactor,
	)
	var i StormPolicy
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Kind,
		&i.ThresholdAvail,
		&i.WindowSeconds,
		&i.CooldownSeconds,
		&i.MaxCoverageFactor,
		&i.CreatedAt,
	)
	return i, err
}

const markStormEventResolved = `-- name: MarkStormEventResolved :one
UPDATE storm_events
SET ended_at = $2
WHERE id = $1
RETURNING id, service_id, kind, started_at, ended_at
`

type MarkStormEventResolvedParams struct {
	ID      int64        `json:"id"`
	EndedAt sql.NullTime `json:"ended_at"`
}

func (q *Queries) MarkStormEventResolved(ctx context.Context, arg MarkStormEventResolvedParams) (StormEvent, error) {
	row := q.db.QueryRowContext(ctx, markStormEventResolved, arg.ID, arg.EndedAt)
	var i StormEvent
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Kind,
		&i.StartedAt,
		&i.EndedAt,
	)
	return i, err
}

const markUsageSnapshotInvoiced = `-- name: MarkUsageSnapshotInvoiced :exec
UPDATE usage_snapshots
SET invoice_id = $1
WHERE id = $2
`

type MarkUsageSnapshotInvoicedParams struct {
	InvoiceID sql.NullInt64 `json:"invoice_id"`
	ID        int64         `json:"id"`
}

func (q *Queries) MarkUsageSnapshotInvoiced(ctx context.Context, arg MarkUsageSnapshotInvoicedParams) error {
	_, err := q.db.ExecContext(ctx, markUsageSnapshotInvoiced, arg.InvoiceID, arg.ID)
	return err
}

const softDeleteService = `-- name: SoftDeleteService :one
UPDATE services
SET deleted_at = NOW()
WHERE id = $1
  AND customer_id = $2
  AND deleted_at IS NULL
RETURNING id, customer_id, name, primary_cdn, backup_cdn, created_at, deleted_at
`

type SoftDeleteServiceParams struct {
	ID         int64 `json:"id"`
	CustomerID int64 `json:"customer_id"`
}

func (q *Queries) SoftDeleteService(ctx context.Context, arg SoftDeleteServiceParams) (Service, error) {
	row := q.db.QueryRowContext(ctx, softDeleteService, arg.ID, arg.CustomerID)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Name,
		&i.PrimaryCdn,
		&i.BackupCdn,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateService = `-- name: UpdateService :one
UPDATE services
SET name = $3,
    primary_cdn = $4,
    backup_cdn = $5
WHERE id = $1
  AND customer_id = $2
RETURNING id, customer_id, name, primary_cdn, backup_cdn, created_at, deleted_at
`

type UpdateServiceParams struct {
	ID         int64  `json:"id"`
	CustomerID int64  `json:"customer_id"`
	Name       string `json:"name"`
	PrimaryCdn string `json:"primary_cdn"`
	BackupCdn  string `json:"backup_cdn"`
}

func (q *Queries) UpdateService(ctx context.Context, arg UpdateServiceParams) (Service, error) {
	row := q.db.QueryRowContext(ctx, updateService,
		arg.ID,
		arg.CustomerID,
		arg.Name,
		arg.PrimaryCdn,
		arg.BackupCdn,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Name,
		&i.PrimaryCdn,
		&i.BackupCdn,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateStormPolicy = `-- name: UpdateStormPolicy :one
UPDATE storm_policies
SET kind = $3,
    threshold_avail = $4,
    window_seconds = $5,
    cooldown_seconds = $6,
    max_coverage_factor = $7
WHERE id = $1
  AND service_id = $2
RETURNING id, service_id, kind, threshold_avail, window_seconds, cooldown_seconds, max_coverage_factor, created_at
`

type UpdateStormPolicyParams struct {
	ID                int64   `json:"id"`
	ServiceID         int64   `json:"service_id"`
	Kind              string  `json:"kind"`
	ThresholdAvail    float64 `json:"threshold_avail"`
	WindowSeconds     int32   `json:"window_seconds"`
	CooldownSeconds   int32   `json:"cooldown_seconds"`
	MaxCoverageFactor float64 `json:"max_coverage_factor"`
}

func (q *Queries) UpdateStormPolicy(ctx context.Context, arg UpdateStormPolicyParams) (StormPolicy, error) {
	row := q.db.QueryRowContext(ctx, updateStormPolicy,
		arg.ID,
		arg.ServiceID,
		arg.Kind,
		arg.ThresholdAvail,
		arg.WindowSeconds,
		arg.CooldownSeconds,
		arg.MaxCoverageFactor,
	)
	var i StormPolicy
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.Kind,
		&i.ThresholdAvail,
		&i.WindowSeconds,
		&i.CooldownSeconds,
		&i.MaxCoverageFactor,
		&i.CreatedAt,
	)
	return i, err
}
